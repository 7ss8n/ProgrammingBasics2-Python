Для виконання лабораторної роботи та представлення результатів її виконання потрібно клонувати проект за посиланням https://github.com/anrom7/linked та виконати наступні завдання.

Завдання 1. Вивчити реалізацію Multiset ADT, яка використовує структуру даних – однозв’язаний список. 
Доповнити реалізацію Multiset ADT наступними методами:

    remove_all(head), приймає посилання на однозв’язаний список, по черзі видаляє всі його вузли та повертає значення. 
	(якщо remove_all це метод класу то при його визначенні remove_all(self)
    split_half(head), приймає посилання на однозв’язаний список, ділить його на дві частини і повертає посилання на ці дві частини. 
	Якщо в структурі тільки один вузол то метод повинен повертати None. 
	(якщо split_half це метод класу то при його визначенні split_half(self)) 



Завдання 2. У Polynomial ADT реалізувати всі відсутні методи.

Завдання 3. Швидка обробка цілочисельних значень в обчислювальних системах ґрунтується на реалізації цілих чисел на апаратному рівні. У випадку, якщо потрібно працювати з великими цілими значеннями апаратний рівень не може забезпечити їх реалізацію. Наприклад, якщо використовується 32-бітна архітектура то цілі
обмежуються діапазоном від 2,147,483,648 до -2,147,483,647. 64-бітна архітектура дозволяє збільшити цей діапазон від 9,223,372,036,854,775,808 до 9,223,372,036,854,775,807. В дослідженнях простих чисел, наприклад, може використовуватися число Скьюза а це ((10**10)**10)**34 . Як реалізувати представлення та обробку таких чисел? В Python реалізовано тип integer і це забезпечує незалежну від платформи обробку таких чисел. Реалізація типу integer відповідає програмному рівню на якому збереження і всі операції, які можуть бути виконані над значеннями здійснюються на основі виконуваних інструкцій у програмі, а не апаратними засобами. Можна визначити ADT Big Integer, який можна використовувати для зберігання і обробки
цілочисельних значень будь-якого розміру, так само, як вбудований тип integer в Python. Описати цей абстрактний тим можна наступним чином: 5

    BigInteger( initValue = "0" ): створення нового великого цілого числа значення якого встановлюється з заданого рядка.
    toString(): повертає велике ціле число як рядок.
    comparable(other): порівнює велике ціле число з іншим великим числом. Порівняння можна здійснити за допомогою будь якого з логічних операторів: <, <=, >, >=, ==, !=.
    arithmetic(rhsInt): повертає новий BigInteger об’єкт як результат виконання арифметичних операцій між self та rhsInt великими цілими числами. Потрібно реалізувати підтримку наступних операцій: +, -, *, //, %, **.
    bitwise-ops(rhsInt): повертає новий BigInteger об’єкт який є результатом застосування однієї з бітових операцій між self та rhsInt великими цілими числами. Потрібно реалізувати підтримку наступних операцій: |, &, ^, <<, >>. (https://docs.python.org/3.5/library/stdtypes.html?highlight=int#numeric-types-int-float-complex)

При реалізації Big Integer ADT потрібно використовувати двозв'язний список в якому кожна цифра цілого числа зберігається в окремому вузлі. Вузли повинні бути впорядковані від найменшої значущої цифри числа до найбільшої.


Рекомендації для реалізації BigInteger

1. Для реалізації операторів порівняння, арифметичних та побітових операцій реалізовуйте відповідні методи.

https://uk.wikibooks.org/wiki/Пориньте_у_Python_3/Імена_магічних_методів

2. Для постійного контролю напишіть модуль який буде постійно тестувати ті оператори, що ви вже реалізували та поточний, над яким зараз працюєте.

3. Додавання (числа можуть бути додатні та від'ємні)

Доцільно розробити допоміжний метод Звичайне додавання — до більшого числа додається менше.

В допоміжному методі Звичайне додавання потрібно створити нове число BigInteger (для збереження результату додавання) й у циклі додавати цифри чисел починаючи з молодших розрядів. Якщо сума цифри першого числа та цифри другого числа більша 9 то потрібно до результату додати остачу від ділення суми на 10 і встановити прапорець, який буде вказувати що від до наступної першої цифри потрібно додати 1 (змінна, яка буде мати значення 1 чи 0).

Метод __add__.

Якщо знаки однакові -> звичайне додавання

Якщо знаки різні й по модулю перше число більше другого числа -> Звичайне віднімання від першого числа другого числа і знак першого буде знаком результату

Якщо знаки різні й по модулю друге число більше першого числа -> Звичайне віднімання від другого числа першого числа і знак другого буде знаком результату.

В іншому випадку числа однакові й результат це BigInteger нуль.


4. Віднімання (числа можуть бути додатні та від'ємні)

Доцільно розробити допоміжний метод Звичайне віднімання — від більшого числа віднімається менше.

В допоміжному методі Звичайне віднімання потрібно створити нове число BigInteger (для збереження результату віднімання) й у циклі віднімати цифри чисел починаючи з молодших розрядів. Якщо цифра першого числа менша за цифру другого числа то потрібно до першого числа додати 10 й до результату додати результат віднімання і встановити прапорець, який буде вказувати, що від наступної цифри першого числа потрібно відняти 1.

Метод __sub__ віднімання

Змінити знак другого операнда і додати числа


5. Множення (числа можуть бути додатні та від'ємні)

Доцільно розробити допоміжний метод Множення на цифру.

В допоміжному методі Множення на цифру потрібно створити нове число BigInteger (для збереження результату множення) й у циклі множити цифри числа на число починаючи з молодших розрядів. Якщо знайдено результат множення двох цифр то остачу ділення добутку на 10 зберегти у результаті, а результат ділення добутку націло на 10 додати до результату наступної ітерації.

Цей метод також можна реалізувати через додавання числа потрібну кількість разів.

Метод __mul__

В циклі по цифрах другого множника починаючи з молодших розрядів викликати Множення на цифру. Результат множення це сума результатів множення на цифру з до множенням (додавання нуля до представлення числа) кожного з результатів множення крім першого на 10.

123 * 17 = (123*1)*10 + (123*7)*1


6. Цілочисельне ділення (числа можуть бути додатні та від'ємні).

через віднімання


7. Остача від ділення (числа можуть бути додатні та від'ємні).

Остача x%y -> x - (y * (x // y))


8. Піднесення до степеня (числа можуть бути додатні та від'ємні).

Виконати множення потрібну кількість разів. Можливо також рекурсивно, наприклад pow(6, 8) == pow(pow(6, 4), 2)


9. Побітові оператори

Для реалізації побітових операторів потрібно розробити допоміжні методи:

Перетворення звичайного BigInteger в двійкове BigInteger де значеннями у вузлах будуть 0 або 1. Для такого перетворення потрібно ділити число на 2 до тих пір поки не залишиться в остачі 1 або 0. Шукане число це остачі від ділення починаючи від останньої остачі (найстарший розряд).

Перетворення двійкового BigInteger у звичайне BigInteger. Кожне значення помножити на 2 у відповідному степені (1011 = 1*20+1*21+0*22+1*23)


&, ^, | Побітові and, xor та or — Працюємо тільки з додатними числами.

Довше число перший операнд. Можна доповнити коротше число нулями у старших розрядах. Результат двійкове BigInteger. Операнди (числа звичайні BigInteger) перетворити у двійкові. Цикл по цифрах чисел й у результат додається результат and (xor, or) між двома цифрами.


>> Зсув вправо на n бітів еквівалентний діленню на  pow(2,n) без контролю переповнення

<< Зсув вліво на n бітів еквівалентний множенню на pow(2,n) без контролю переповнення

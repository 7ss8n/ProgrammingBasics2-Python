Для виконання лабораторної роботи та представлення результатів її виконання потрібно клонувати проекти за посиланнями https://github.com/anrom7/Trees,  https://github.com/anrom7/Trees_easy,  https://github.com/anrom7/binary_search_tree та  виконати наступні  завдання.


Завдання1.

Доповнити клас LinkedBST наступними методами:

        Метод height. Метод повинен повертати висоту дерева, яка визначається у спосіб, який було розглянуто на лекції.

        Метод isBalanced. Метод повинен повертати True, якщо висота дерева менша ніж 2 * log2(n + 1) - 1, де n це кількість вершин або False в іншому випадку.

Збалансоване дерево в загальному розумінні цього слова — це такий різновид бінарного дерева пошуку, яке автоматично підтримує свою висоту, тобто кількість рівнів вершин під коренем є мінімальною. Ця властивість є важливою тому, що час виконання більшість алгоритмів на бінарних деревах пошуку пропорційний до їхньої висоти, а звичайні бінарні дерева пошуку можуть мати досить велику висоту в тривіальних ситуаціях.

Бінарні дерева пошуку набагато ефективніші в операціях пошуку, аніж лінійні структури, в яких витрати часу на пошук пропорційні O(n), де n — розмір масиву даних, тоді як в повному бінарному дереві цей час пропорційний в середньому O(log2n) або O(h), де h — висота дерева (хоча гарантувати, що h не перевищує log2n можна лише для збалансованих дерев, які є ефективнішими на пошукових алгоритмах, аніж прості бінарні дерева пошуку).

        Метод rebalance. Цей метод повинен здійснювати копіювання елементів дерева у список (масив) при його симетричному обході та очищувати дерево. Після цього в методі потрібно реалізувати копіювання елементів зі списку в дерево таким чином щоб дерево було збалансованим. Підказка: Доцільно скористатися допоміжною функцією, яка буде додавати в дерево елемент що знаходиться посередині впорядкованого списку. Рекурсивний виклик цієї функції дозволить побудувати збалансоване дерево на основі відсортованого списку елементів.

        Методи successor та predecessor. Кожен з цих методів очікує елемент, як аргумент при виклику і повертає елемент або None. Метод successor це повинен повертати найменший елемент в дереві, який більший заданого, а predecessor - найбільший елемент в дереві, який менший даного. Потрібно зауважити що successor існує навіть якщо заданий елемент відсутній у дереві.

        Метод rangeFind. Метод повинен отримати два елементи, як аргументи при виклику, і призначений для визначення меж пошуку в дереві. Метод повинен повертати список (масив) елементів, які будуть знайдені в заданих межах при обході дерева.


Завдання2.

Провести дослідження реалізації бінарного дерева пошуку для вирішення задач пошуку.  Дослідження провести на основі вирішення наступних задач при роботі зі словником слів, який збережений у файлі.  Для досліджень потрібно розробити модуль search_time_test.py який дозволить:

a) визначити час пошуку 10000 випадкових слів у впорядкованому за абеткою словнику (пошук у списку слів з використанням методів вбудованого типу list).

b) визначити час пошуку 10000 випадкових слів у словнику, який представлений у вигляді бінарного дерева пошуку. Бінарне дерево пошуку будується на основі словника в якому слова не впорядковані за абеткою.

c) Визначити час пошуку 10000 випадкових слів у словнику, який представлений у вигляді збалансованого бінарного дерева пошуку.


Завдання 3.

Розробити програму для гри в хрестики – нулики.

Для виконання завдання потрібно звернути увагу на необхідність:

    Створення класу Board, який буде містити масив рядків 3x3 для збереження поточного стану гри. Також в цьому класі доцільно визначити змінні для збереження останнього ходу (символ та позиція), який призвів до даного стану.

    Створення методу для перевірки поточного стану на ігровому полі: чи хтось виграв; чи нічия; або результат не визначений – гра продовжується.

    Створення методу для побудови дерева гри, шляхом розширення (додаванням двох дочірніх вершин) від кореня дерева. Метод можна реалізувати у довільний спосіб, але потрібно пам’ятати що він повинен передбачати виконання рекурсивних викликів. Алгоритм прийняття рішення описує наступний псевдокод:

        Побудувати дерево (цей крок повинен бути рекурсивним)

        Обчислити бали для кожної з гілок (перевірити листи дерева на виграш, програш, нічию та додати результати (+1, -1, 0)) (це також рекурсивний крок де нижні вершини будуть передавати цілі числа своїм батькам, які будуть їх підраховувати)

        Гілка з більшою кількістю балів дозволить вибрати наступний хід.

    Розроблення логіки гри, яка дозволить робити ходи (вводити дані) людині та комп’ютеру (модуль game.py).

    Оброблення помилок при спробі зробити помилковий хід, наприклад, коли користувач пробує вибрати вже зайняту позицію, або номер позиції виходить за межі ігрового поля. Такі помилки повинні збуджувати винятки, які належним чином повинні бути оброблені з виведенням відповідних повідомлень та можливістю продовжити гру.

    Виведення на екран стану ігрового поля після кожного з ходів

Розв’язок завдання представити у вигляді окремого проекту в репозитарії GitHub, який повинен містити наступні модулі board.py, btree.py, btnode.py, game.py.